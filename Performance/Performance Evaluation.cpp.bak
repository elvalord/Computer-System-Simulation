// Performance Evaluation.cpp : Defines the entry point for the console application.
//

#include "stdlib.h"
#include "math.h"
#include "time.h"
#include "user_definition.h"
#include <iostream>
#include <iomanip>
#include <fstream>


using namespace std;


typedef int Flag;
typedef int Status;

Status Cpu_Status=IDLE;
Status Disk1_Status=IDLE;
Status Disk2_Status=IDLE;



typedef struct

{
	float OccurTime;  //事件发生时刻
	float ReservedArrivalTime; //保留到达时刻，用来计算直到离开时的时间差
	int NType;      //事件类型

}Event,ElemType;//事件类型，有序链表LinkList的数据元类型

typedef struct LNode // 结点类型

{

   ElemType data;
   LNode *next;

 }*Link,*Position;

struct LinkList // 链表类型

 {

   Link head,tail; // 分别指向线性链表中的头结点和最后一个结点

   int len; // 指示线性链表中数据元素的个数

 };

typedef LinkList EventList; // 事件链表类型，定义为有序链表

typedef struct//暂时没想好队列的元素有什么用

{

	float ArrivalTime;
	int Duration;

}QElemType;     //队列的数据元素类型

typedef struct QNode

{

   QElemType data;

   QNode *next;

}*QueuePtr;      //队列

struct LinkQueue

{

	QueuePtr front,rear; // 队头、队尾指针

};

EventList ev;//事件表

Event en; //事件

Event et;//临时变量

LinkQueue Q_CPU;
LinkQueue Q_memory;
LinkQueue Q_disk1;
LinkQueue Q_disk2;


QElemType temp_record; //客户记录


/*important user's variables*/
long long holdrand[5];
int current_job_number=0;
float total_Cpu_time=0;
float total_Disk1_time=0;
float total_Disk2_time=0;
int arrival_lambda=1;
int simulated_time=300;//初始化仿真时间为300s
Flag end_flag=FALSE;
int finished_number=0;
float total_finished_time=0;

float average_memory_queue=0.0;
float total_memory_queue=0;
float previous_operating_memory_time=0.0;

float average_job=0.0;
float total_job=0.0;
float previous_operating_job_time=0.0;

float final_CPU_event_time = 0.0;//因为仿真结束的时候，cup、disk1和disk2最后的操作时间可能比simulated_time大
float final_disk1_event_time = 0.0;
float final_disk2_event_time =0.0;

float current_CPU_utilization;
float current_disk1_utilization;
float current_disk2_utilization;


streambuf *backup , *psbuf;
ofstream filestr;
char *filename;

void Start_Redirect(void)
{
	backup = std::cout.rdbuf();

	filestr.open(filename);

	psbuf = filestr.rdbuf();

	std::cout.rdbuf(psbuf);
}

void Close_Redirect(void)
{

 
	filestr.close(); 

	std::cout.rdbuf(backup);

}



//Type取值为ARRIVAL_TYPE 、CPU_TYPE  、DISK1_TYPE 、DISK2_TYPE 、CPU_PUT 4
int  __cdecl random(int Type)
{
	return (((holdrand[Type] = holdrand[Type] * 214013L + 2531011L) >> 16) & 0x7fff);
}

//此函数返回的是时间间隔,lambda表示单位时间内发生的次数,Type是为了区别调用的不同种子的随机函数
//Type取值为ARRIVAL_TYPE 、CPU_TYPE  、DISK1_TYPE 、DISK2_TYPE 
float Poisson(float lambda,int Type) 
{  
    float z;  
    do  
    {  
        z = ((float)random(Type))/RAND_MAX;  
    }while(z == 0 || z == 1);  
    return (-(1/lambda)*log(1-z));  
} 


int cmp(Event a,Event b)

 { // 依事件a的发生时刻<、=或>事件b的发生时刻分别返回-1、0或1

   if(a.OccurTime==b.OccurTime)

     return 0;
   
   else if(a.OccurTime<b.OccurTime)
	 
	  return -1;

   else

     return 1;

 }

Status InitList(LinkList &L)

{ // 构造一个空的线性链表

   Link p;

   p=(Link)malloc(sizeof(LNode)); // 生成头结点

   if(p)

   {

     p->next=NULL;

     L.head=L.tail=p;

     L.len=0;

     return OK;

   }

   else

     return ERROR;

}//InitList

Status ClearList ( LinkList &L )  
{   
	Link p; 

	while(L.head->next)
	{	
		p=L.head->next;

		L.head->next=p->next;

		free(p);

	}

	L.tail=L.head;

	L.len=0;

	return OK;
}

Status InitQueue(LinkQueue &Q)

{ // 构造一个空队列Q

   if(!(Q.front=Q.rear=(QueuePtr)malloc(sizeof(QNode))))

     exit(-1);

   Q.front->next=NULL;

   return OK;

}//InitQueue

Status ClearQueue(LinkQueue &Q)//将Q清空
{
	 if(Q.front->next== NULL)
	  return OK;
	 QueuePtr s = Q.front->next,p;
	 while(s)
	 {
	  p=s->next;
	  free(s);
	  s = p;
	 }
	 Q.rear =  Q.front;
	 Q.front->next=NULL;
	 return OK;
}
Status OrderInsert(LinkList &L,ElemType e,int (*comp)(ElemType,ElemType))

 { // 已知L为有序线性链表，将元素e按非降序插入在L中。（用于一元多项式）

   Link o,p,q;

   q=L.head;

   p=q->next;

   while(p!=NULL&&comp(p->data,e)<0) // p不是表尾且元素值小于e

   {

     q=p;

     p=p->next;

   }

   o=(Link)malloc(sizeof(LNode)); // 生成结点

   o->data=e; // 赋值

   q->next=o; // 插入

   o->next=p;

   L.len++; // 表长加1

   if(!p) // 插在表尾

     L.tail=o; // 修改尾结点

   return OK;

 }//OrderInsert


/*
Flag CPU_Random(void)
CPU事件输出概率函数，返回值TO_DISK1，TO_DISK2，LEAVE
*/
Flag CPU_Random(void)

{
	int rand_num;
	rand_num=random(CPU_PUT)%10+1;//1到10之间的随机数
	if(rand_num<=7)
		return TO_DISK1;     //概率是0.7
	else if(rand_num>7&&rand_num<10)
		return TO_DISK2;	 //概率是0.2
	else
		return LEAVE;		//概率是0.1

}//CPU_Random

int QueueLength(LinkQueue Q)

{ // 求队列的长度

   int i=0;

   QueuePtr p;

   p=Q.front;

   while(Q.rear!=p)

   {

     i++;

     p=p->next;

   }

   return i;

}//QueueLength

Status EnQueue(LinkQueue &Q,QElemType e)

{ // 插入元素e为Q的新的队尾元素

   QueuePtr p;

   if(!(p=(QueuePtr)malloc(sizeof(QNode)))) // 存储分配失败

     exit(OVERFLOW);

   p->data=e;

   p->next=NULL;

   Q.rear->next=p;

   Q.rear=p;

   return OK;

}//EnQueue

Status DeQueue(LinkQueue &Q,QElemType &e)

 { // 若队列不空,删除Q的队头元素,用e返回其值,并返回OK,否则返回ERROR，此操作队头出队

   QueuePtr p;

   if(Q.front==Q.rear)

     return ERROR;

   p=Q.front->next;

   e=p->data;

   Q.front->next=p->next;

   if(Q.rear==p)

     Q.rear=Q.front;

   free(p);

   return OK;

 }//DeQueue

Status GetHead(LinkQueue Q,QElemType &e)

{ // 若队列不空,则用e返回Q的队头元素,并返回OK,否则返回ERROR,此操作只是提取信息队头元素不出队

   QueuePtr p;

   if(Q.front==Q.rear)

     return ERROR;

   p=Q.front->next;

   e=p->data;

   return OK;

}//GetHead

 Position GetHead(LinkList L)

 { // 返回线性链表L中头结点的位置

   return L.head;

 }//GetHead

Status QueueEmpty(LinkQueue Q)

 { // 若Q为空队列,则返回TRUE,否则返回FALSE

   if(Q.front==Q.rear)

     return TRUE;

   else

     return FALSE;

 }//QueueEmpty


 Status ListEmpty(LinkList L)

 { // 若线性链表L为空表，则返回TRUE，否则返回FALSE

   if(L.len)

     return FALSE;

   else

     return TRUE;

 }//ListEmpty

Status DelFirst(LinkList &L,Link h,Link &q) // 形参增加L,因为需修改L

{ // h指向L的一个结点，把h当做头结点，删除链表中的第一个结点并以q返回。

   // 若链表为空(h指向尾结点)，q=NULL，返回FALSE

   q=h->next;

   if(q) // 链表非空

   {

     h->next=q->next;

     if(!h->next) // 删除尾结点

       L.tail=h; // 修改尾指针
	
// 	 cout<<L.len<<endl;

     L.len--;

     return OK;

   }

   else

     return FALSE; // 链表空

}//DelFirst

ElemType GetCurElem(Link p)

{ // 已知p指向线性链表中的一个结点，返回p所指结点中数据元素的值

   return p->data;

}//GetCurElem


void Re_initialization()

{
	
	ClearList(ev);	//清空链表

	en.OccurTime=0;

	en.ReservedArrivalTime=0;

	en.NType=0;

	OrderInsert(ev,en,cmp);//插入第一个到达事件
	
    ClearQueue(Q_CPU);	//清空CPU队列

	ClearQueue(Q_memory);//清空内存队列

    ClearQueue(Q_disk1);//清空DISK1队列

	ClearQueue(Q_disk2);//清空DISK2队列

	/*系统时间为第一个随机函数的种子，其他的各个随机函数种子各加一，
	我把随机函数rand的源码给自己改写了，所以可以使用不同的种子*/
/*	holdrand[0]=time(NULL);  //取系统时间作为第一个随机函数的种子
	holdrand[1]=holdrand[0]+1;
	holdrand[2]=holdrand[1]+1;
	holdrand[3]=holdrand[2]+1;
	holdrand[4]=holdrand[3]+1;*/

//	cout<<holdrand[0]<<endl;

	Cpu_Status=IDLE;
	Disk1_Status=IDLE;
	Disk2_Status=IDLE;

	current_job_number=0;

	end_flag=FALSE;

	total_Cpu_time=0;
	total_Disk1_time=0;
	total_Disk2_time=0;
	finished_number=0;
    total_finished_time=0;
	average_memory_queue=0.0;
	total_memory_queue=0;
	previous_operating_memory_time=0.0;
    average_job=0.0;
	total_job=0.0;
	previous_operating_job_time=0.0;
	final_CPU_event_time = 0.0;
	final_disk1_event_time = 0.0;
	final_disk2_event_time =0.0;
	current_CPU_utilization = 0.0;
	current_disk1_utilization = 0.0;
	current_disk2_utilization = 0.0;

}//Reinitialization
void Initialization()

{
	
	InitList(ev);	//初始化链表

	en.OccurTime=0;
	
	en.ReservedArrivalTime=0;

	en.NType=0;

	OrderInsert(ev,en,cmp);//插入第一个到达事件

    InitQueue(Q_CPU);	//初始化CPU队列

	InitQueue(Q_memory);//初始化内存队列

	InitQueue(Q_disk1);//初始化DISK1队列

	InitQueue(Q_disk2);//初始化DISK2队列

	/*系统时间为第一个随机函数的种子，其他的各个随机函数种子各加一，
	我把随机函数rand的源码给自己改写了，所以可以使用不同的种子*/
	holdrand[0]=time(NULL);  //取系统时间作为第一个随机函数的种子
	holdrand[1]=holdrand[0]+1;
	holdrand[2]=holdrand[1]+1;
	holdrand[3]=holdrand[2]+1;
	holdrand[4]=holdrand[3]+1;

	Cpu_Status=IDLE;
	Disk1_Status=IDLE;
	Disk2_Status=IDLE;

	current_job_number=0;

	end_flag=FALSE;

	total_Cpu_time=0;
	total_Disk1_time=0;
	total_Disk2_time=0;
	finished_number=0;
    total_finished_time=0;	
	average_memory_queue=0.0;
	total_memory_queue=0;
	previous_operating_memory_time=0.0;
	average_job=0.0;
	total_job=0.0;
	previous_operating_job_time=0.0;
	final_CPU_event_time = 0.0;
	final_disk1_event_time = 0.0;
	final_disk2_event_time =0.0;
	current_CPU_utilization = 0.0;
	current_disk1_utilization = 0.0;
	current_disk2_utilization = 0.0;


}//Initialization


void Arrival(void)
{
	
		QElemType f;

		float intertime=0;
		
		intertime=Poisson(arrival_lambda,ARRIVAL_TYPE);//按照ARRIVAL类型产生随机间隔时间

		et.OccurTime=en.OccurTime+intertime;//计算下一个到达事件的发生时间

		et.ReservedArrivalTime=et.OccurTime;//此处要插入的是新的到达事件，故ReservedArrivalTime=OccurTime;

		et.NType=JOB_ARRIVAL;//定义将要插入的事件为到达事件

		OrderInsert(ev,et,cmp);//将新的到达事件插入事件链表

	//判断系统当前job数是否小于最大处理job数，此处MAX_JOB_NUMBER就是代表内存大小的一个数，宏定义为3，2Gbyte时应该为7
	//若当前job数已经达到上限，job进入内存队列
	if(current_job_number<MAX_JOB_NUMBER)//内存足够
	{
		total_job += current_job_number*(en.OccurTime-previous_operating_job_time);//统计总和

		previous_operating_job_time = en.OccurTime;	//保留此次变化的发生时间

		cout<<en.OccurTime<<"\t"<<current_job_number<<endl;//输出current_job_number变化前的数值

		current_job_number++;//系统当前job数+1

		cout<<en.OccurTime<<"\t"<<current_job_number<<endl;//输出current_job_number变化后的数值

		if(Cpu_Status==IDLE) //CPU状态IDLE
		{
			Cpu_Status=BUSY;
			
			intertime=Poisson(CPU_LAMBDA,CPU_TYPE);//按照CPU类型产生随机间隔时间

			total_Cpu_time +=intertime;//统计CPU忙碌时间

			et.OccurTime=en.OccurTime+intertime;//确定将要插入的事件的发生时间

			et.ReservedArrivalTime=en.ReservedArrivalTime;//ReservedArrivalTime作为每一个事件都随身携带的属性

			et.NType=END_PROCESSING;//插入的是END_PROCESSING事件

			OrderInsert(ev,et,cmp);
		}

		else//CPU状态BUSY
		{
			f.ArrivalTime=en.ReservedArrivalTime;

			f.Duration=NULL;

			EnQueue(Q_CPU,f);
		}
	}
	
	else//内存不足
	{
		f.ArrivalTime=en.ReservedArrivalTime;

		f.Duration=NULL;

//		cout<<en.OccurTime<<"\t"<<QueueLength(Q_memory)<<endl;//重定向输出变化前的值

		total_memory_queue += QueueLength(Q_memory)*(en.OccurTime-previous_operating_memory_time);//统计内存队列

		previous_operating_memory_time = en.OccurTime;//修改，刚才居然忘记了

		EnQueue(Q_memory,f);

	//	cout<<en.OccurTime<<"\t"<<QueueLength(Q_memory)<<endl;//重定向输出变化后的值
	}
		
}
/**
void Leave(void)用来处理job离开系统的函数
该函数首先检测内存队列是否为空，
若内存队列非空，则让内存队列队头出队，CPU队列加入一个元素
若内存队列为空，则释放内存，当前job数减1
***/
void Leave(void)
{
	QElemType f;

	finished_number++;//finished_number为了记录离开系统的事件个数
	
	total_finished_time += en.OccurTime-en.ReservedArrivalTime; //统计事件的总耗时
	/*
	cout<<finished_number
		<<"\t"<< en.ReservedArrivalTime
		<<"\t"<< en.OccurTime
		<<"\t"<< en.OccurTime-en.ReservedArrivalTime<<endl; //输出到文件以便分析数据*/
	
	if(!QueueEmpty(Q_memory)&&!end_flag)//只有内存队列非空并且仿真时间没有结束的时候，内存队列的job才可以进入CPU队列
	{
//		cout<<en.OccurTime<<"\t"<<QueueLength(Q_memory)<<endl;//重定向输出变化前的值

		total_memory_queue += QueueLength(Q_memory)*(en.OccurTime-previous_operating_memory_time);//统计内存队列

		previous_operating_memory_time = en.OccurTime;
		
		DeQueue(Q_memory,temp_record);

	//	cout<<en.OccurTime<<"\t"<<QueueLength(Q_memory)<<endl;//重定向输出变化后的值

		f.ArrivalTime=temp_record.ArrivalTime;

		f.Duration=NULL;

		EnQueue(Q_CPU,f);
	}
	else
	{
		total_job += current_job_number*(en.OccurTime-previous_operating_job_time);//统计总和

		previous_operating_job_time = en.OccurTime;	//保留此次变化的发生时间

		cout<<en.OccurTime<<"\t"<<current_job_number<<endl;//输出current_job_number变化前的数值

		current_job_number--;//系统当前job数-1

		cout<<en.OccurTime<<"\t"<<current_job_number<<endl;//输出current_job_number变化后的数值
	}
}
/**
void ToDisk1(void) 为处理job往DISK1存储的函数
*/
void ToDisk1(void)
{
	
	QElemType f;

	float intertime=0;

	if(Disk1_Status==IDLE)//DISK1状态IDLE
	{
		Disk1_Status=BUSY;
			
		intertime=Poisson(DISK1_LAMBDA,DISK1_TYPE);//按照DISK1类型产生随机间隔时间

		total_Disk1_time+=intertime;

		et.OccurTime=en.OccurTime+intertime;//确定插入事件的发生时间

		et.ReservedArrivalTime=en.ReservedArrivalTime;//ReservedArrivalTime作为每一个事件都随身携带的属性

		et.NType=END_DISK1;//插入事件类型是END_DISK1

		OrderInsert(ev,et,cmp);

	}

	else//DISK1状态BUSY
	{
		f.ArrivalTime=en.ReservedArrivalTime;

		f.Duration=NULL;

		EnQueue(Q_disk1,f);
	}
}

/**
void ToDisk2(void) 为处理job往DISK1存储的函数
*/
void ToDisk2(void)
{
	QElemType f;

	float intertime=0;

	if(Disk2_Status==IDLE)//DISK2状态IDLE
	{
		Disk2_Status=BUSY;
			
		intertime=Poisson(DISK2_LAMBDA,DISK2_TYPE);//按照DISK2类型产生随机间隔时间

		total_Disk2_time+=intertime;

		et.OccurTime=en.OccurTime+intertime;//确定插入事件的发生时间

		et.ReservedArrivalTime=en.ReservedArrivalTime;//ReservedArrivalTime作为每一个事件都随身携带的属性

		et.NType=END_DISK2;//插入事件类型是END_DISK2

		OrderInsert(ev,et,cmp);

	}

	else//DISK2状态BUSY
	{
		f.ArrivalTime=en.ReservedArrivalTime;

		f.Duration=NULL;

		EnQueue(Q_disk2,f);
	}
}

void End_Processing(void)
{
	float intertime=0;

	final_CPU_event_time = en.OccurTime;

	if(final_CPU_event_time != 0)
	{
		current_CPU_utilization = total_Cpu_time/final_CPU_event_time;
	}

	switch(CPU_Random())//CPU_Random()返回Flag值分别为LEAVE、TO_DISK2、TO_DISK1
	{
		case LEAVE: Leave();break;
		case TO_DISK2: ToDisk2();break;
		case TO_DISK1: ToDisk1();break;
		default:break;
	}

//如果CPU队列非空，设定Q_CPU的一个离开事件，并插入事件表
	if(!QueueEmpty(Q_CPU)) //CPU队列非空
	{
		
		DeQueue(Q_CPU,temp_record);//队头元素出队

		Cpu_Status=BUSY;//工作状态BUSY，必须设定
			
		intertime=Poisson(CPU_LAMBDA,CPU_TYPE);//按照CPU类型产生随机间隔时间

		total_Cpu_time +=intertime;//统计CPU运行时间

		et.OccurTime=en.OccurTime+intertime;

		et.ReservedArrivalTime=temp_record.ArrivalTime;//ReservedArrivalTime作为每一个事件都随身携带的属性

		et.NType=END_PROCESSING;//插入事件类型为END_PROCESSING

		OrderInsert(ev,et,cmp);
	}

	else//CPU队列为空
	{
		Cpu_Status=IDLE;
	}

}

void End_Disk1(void)
{
	float intertime=0;

	
	final_disk1_event_time = en.OccurTime;

	if(final_disk1_event_time != 0)
	{
		current_disk1_utilization = total_Disk1_time/final_disk1_event_time;
	}

	QElemType f;
	
	//判断CPU状态，若空闲则触发END_PROCESSING事件，否则CPU队列入队一个新元素
	if(Cpu_Status==IDLE)//CPU状态IDLE
	{
		Cpu_Status=BUSY;

		intertime=Poisson(CPU_LAMBDA,CPU_TYPE);//按照CPU类型产生随机间隔时间

		total_Cpu_time +=intertime;//统计CPU运行时间

		et.OccurTime=en.OccurTime+intertime;

		et.ReservedArrivalTime=en.ReservedArrivalTime;//ReservedArrivalTime作为每一个事件都随身携带的属性

		et.NType=END_PROCESSING;//插入事件类型为END_PROCESSING

		OrderInsert(ev,et,cmp);
	}
	else//CPU状态BUSY
	{
		f.ArrivalTime=en.ReservedArrivalTime;

		f.Duration=NULL;

		EnQueue(Q_CPU,f);	
	}

	//设定Q_disk1的一个离开事件，并插入事件表
	if(!QueueEmpty(Q_disk1)) //队列非空
	{
		DeQueue(Q_disk1,temp_record);

		Disk1_Status=BUSY;//状态一定要设定BUSY
			
		intertime=Poisson(DISK1_LAMBDA,DISK1_TYPE);//按照DISK1类型产生随机间隔时间

		total_Disk1_time+=intertime;

		et.OccurTime=en.OccurTime+intertime;

		et.ReservedArrivalTime=temp_record.ArrivalTime;//ReservedArrivalTime作为每一个事件都随身携带的属性

		et.NType=END_DISK1;//插入事件类型为END_DISK1

		OrderInsert(ev,et,cmp);	
	}
	else//队列空
	{
		Disk1_Status=IDLE;
	}

}

void End_Disk2(void)
{
	float intertime=0;

	final_disk2_event_time = en.OccurTime;

	if(final_disk2_event_time != 0)
	{
		current_disk2_utilization = total_Disk2_time/final_disk2_event_time;
	}

	QElemType f;
	
	if(Cpu_Status==IDLE)
	{
		Cpu_Status=BUSY;

		intertime=Poisson(CPU_LAMBDA,CPU_TYPE);

		total_Cpu_time +=intertime;

		et.OccurTime=en.OccurTime+intertime;

		et.ReservedArrivalTime=en.ReservedArrivalTime;//ReservedArrivalTime作为每一个事件都随身携带的属性

		et.NType=END_PROCESSING;

		OrderInsert(ev,et,cmp);
	}
	else
	{
		f.ArrivalTime=en.ReservedArrivalTime;

		f.Duration=NULL;

		EnQueue(Q_CPU,f);	
	}

	if(!QueueEmpty(Q_disk2)) //设定Q_disk2的一个离开事件，并插入事件表
	{
		DeQueue(Q_disk2,temp_record);

		Disk2_Status=BUSY;
			
		intertime=Poisson(DISK2_LAMBDA,DISK2_TYPE);

		total_Disk2_time+=intertime;

		et.OccurTime=en.OccurTime+intertime;

		et.ReservedArrivalTime=temp_record.ArrivalTime;//ReservedArrivalTime作为每一个事件都随身携带的属性

		et.NType=END_DISK2;

		OrderInsert(ev,et,cmp);	
	}
	else
	{
		Disk2_Status=IDLE;
	}
}

void Computer_System_Simulation()

{

	Link p;

	cout<<fixed;			//定点输出	

	cout<<setprecision(6);//6位小数

	while(!ListEmpty(ev))//判断事件列表是否为空，为空返回TRUE，否则返回False

	  {
		
		DelFirst(ev,GetHead(ev),p);//删除并取出链表第一个元素

	   en.OccurTime=GetCurElem(p).OccurTime;

	   en.ReservedArrivalTime=GetCurElem(p).ReservedArrivalTime;

	   en.NType=GetCurElem(p).NType;

	   if(en.OccurTime >simulated_time  && end_flag == FALSE ) //当前取出的事件的发生时间和仿真时间比较，只执行了一次！！！
	   {/*
		   if(	end_flag==FALSE)	//到达仿真时间的时候，查看当前的系统各队列长度和当前系统处理的job数
		   {
				cout<<setw(14)<<fixed<<arrival_lambda
					<<setw(14)<<total_Cpu_time
					<<setw(14)<<total_Disk1_time
					<<setw(14)<<total_Disk2_time
					<<setw(14)<<total_finished_time/finished_number<<endl;
			    cout<<"Q_memory_number:"<<QueueLength(Q_memory)<<endl;
			    cout<<"   Q_CPU_number:"<<QueueLength(Q_CPU)<<endl;
			    cout<<" Q_disk1_number:"<<QueueLength(Q_disk1)<<endl;
			    cout<<" Q_disk2_number:"<<QueueLength(Q_disk2)<<endl;
			    cout<<"current_job_number:"<<current_job_number<<endl;

		   }*/
		   //仿真结束时刻内存队列的数目
	//	   cout<<simulated_time<<"\t"<<QueueLength(Q_memory)<<endl;//重定向输出变化前的值
		   //最后一次操作内存队列到仿真时间结束的统计（画一下坐标图那就懂了）
		   total_memory_queue += QueueLength(Q_memory)*(simulated_time-previous_operating_memory_time);//统计内存队列

		   end_flag=TRUE;			
	   }

	   switch(en.NType)//当前的事件类型，分别有JOB_ARRIVAL、END_PROCESSING、END_DISK1、END_DISK2
	   {
	   case JOB_ARRIVAL: 
		   if(	end_flag==FALSE)
		   {
			   Arrival();
		   }
		   break;
	   case END_PROCESSING: End_Processing();break;
	   case END_DISK1: End_Disk1();break;
	   case END_DISK2: End_Disk2();break;
	   default:break;	   
	   }
	   /*
	   	cout<<setw(12)<<final_CPU_event_time<<"\t"<<setw(12)<<current_CPU_utilization*100
		<<"\t"<<setw(12)<<final_disk1_event_time<<"\t"<<setw(12)<<current_disk1_utilization*100
		<<"\t"<<setw(12)<<final_disk2_event_time<<"\t"<<setw(12)<<current_disk2_utilization*100
		<<"\t"<<setw(12)<<en.OccurTime<<"\t"<<setw(12);
		if(en.OccurTime != 0)
			cout<<(total_job+current_job_number*(en.OccurTime-previous_operating_job_time))/en.OccurTime/MAX_JOB_NUMBER*100;
		else
			cout<<0;

		cout<<endl;
	   */

  }//while

}//Computer_System_Simulation


int main()
{

	Initialization();   //初始化各种变量

	cout <<"Please input system simulated time : ";

	cin>>simulated_time;
	
	cout<<"when the maximum job number is "<<MAX_JOB_NUMBER
		<<" and the simulated time is "<<simulated_time
		<<"s,the result:\n\n";
	
	cout<<setw(40)<<"Total"<<setw(9)<<"Average"<<setw(9)<<"Average"<<setw(9)<<"Average"<<setw(12)<<"Utilization"<<endl;

	cout<<setw(6)<<"lambda"
		<<setw(5)<<" CPU"
		<<setw(11)<<" DISK1"
		<<setw(9)<<" DISK2"
		<<setw(9)<<"finished"
		<<setw(9)<<"finished"
		<<setw(9)<<"memory"
		<<setw(9)<<"job"
		<<setw(12)<<"of    "<<endl;	

	cout<<setw(40)<<"number"<<setw(9)<<"time"<<setw(9)<<"queue"<<setw(9)<<"number"<<setw(12)<<"memory   "<<endl;

    char str1[10][15]={"arrival_1.txt","arrival_2.txt","arrival_3.txt","arrival_4.txt",
					  "arrival_5.txt","arrival_6.txt","arrival_7.txt","arrival_8.txt",
					  "arrival_9.txt","arrival_10.txt"};

	char str2[10][15]={"arrival_1.xls","arrival_2.xls","arrival_3.xls","arrival_4.xls",
					  "arrival_5.xls","arrival_6.xls","arrival_7.xls","arrival_8.xls",
					  "arrival_9.xls","arrival_10.xls"};
	filename=&str1[0][0];

	for(arrival_lambda=1;arrival_lambda<=10;arrival_lambda++)//注意这里，我现在只做了一个lambda的，你可以改参数。
	{
	
	 Start_Redirect();

	 Computer_System_Simulation(); //系统仿真函数

	 Close_Redirect();

	 filename +=15;

//	cout<<"finished_number:"<<finished_number<<endl;

	 average_memory_queue = total_memory_queue/simulated_time;

	 average_job = total_job/previous_operating_job_time;//不同于上一行的分母，是因为仿真时间即使到达了，系统还会继续处理系统里的事件。而previous_operating_job_time记录了最后一个离开事件的发生时间
	 	
	cout<<setw(4)<<fixed<<arrival_lambda<<setprecision(2)
		<<setw(8)<<total_Cpu_time/final_CPU_event_time*100<<"%"
		<<setw(8)<<total_Disk1_time/final_disk1_event_time*100<<"%"
		<<setw(8)<<total_Disk2_time/final_disk2_event_time*100<<"%"
		<<setw(9)<<finished_number
		<<setw(9)<<total_finished_time/finished_number
		<<setw(9)<<average_memory_queue
		<<setw(9)<<setprecision(4)<<average_job
		<<setw(9)<<setprecision(2)<<average_job/MAX_JOB_NUMBER*100<<"%"<<endl;
		

	Re_initialization();
	
	}

	cin.get();//这是故意让dos停下来的。
	cin.get();
	return 0;
}



